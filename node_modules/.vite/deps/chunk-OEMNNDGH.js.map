{
  "version": 3,
  "sources": ["../../next/dist/compiled/@edge-runtime/cookies/index.js", "../../next/src/server/web/spec-extension/cookies.ts", "../../next/src/server/web/spec-extension/adapters/reflect.ts", "../../next/src/server/app-render/async-local-storage.ts", "../../next/src/server/app-render/work-async-storage-instance.ts", "../../next/src/server/app-render/work-async-storage.external.ts", "../../next/src/server/web/spec-extension/adapters/request-cookies.ts", "../../next/src/server/app-render/work-unit-async-storage-instance.ts", "../../next/src/client/components/app-router-headers.ts", "../../next/src/shared/lib/invariant-error.ts", "../../next/src/server/app-render/work-unit-async-storage.external.ts", "../../next/src/client/components/hooks-server-context.ts", "../../next/src/client/components/static-generation-bailout.ts", "../../next/src/server/dynamic-rendering-utils.ts", "../../next/src/lib/framework/boundary-constants.tsx", "../../next/src/lib/scheduler.ts", "../../next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts", "../../next/src/server/app-render/dynamic-rendering.ts", "../../next/src/server/create-deduped-by-callsite-server-error-logger.ts", "../../next/src/server/app-render/after-task-async-storage-instance.ts", "../../next/src/server/app-render/after-task-async-storage.external.ts", "../../next/src/server/request/utils.ts", "../../next/src/server/request/cookies.ts", "../../next/src/server/web/spec-extension/adapters/headers.ts", "../../next/src/server/request/headers.ts", "../../next/src/server/request/draft-mode.ts", "../../next/headers.js"],
  "sourcesContent": ["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  RequestCookies: () => RequestCookies,\n  ResponseCookies: () => ResponseCookies,\n  parseCookie: () => parseCookie,\n  parseSetCookie: () => parseSetCookie,\n  stringifyCookie: () => stringifyCookie\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/serialize.ts\nfunction stringifyCookie(c) {\n  var _a;\n  const attrs = [\n    \"path\" in c && c.path && `Path=${c.path}`,\n    \"expires\" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === \"number\" ? new Date(c.expires) : c.expires).toUTCString()}`,\n    \"maxAge\" in c && typeof c.maxAge === \"number\" && `Max-Age=${c.maxAge}`,\n    \"domain\" in c && c.domain && `Domain=${c.domain}`,\n    \"secure\" in c && c.secure && \"Secure\",\n    \"httpOnly\" in c && c.httpOnly && \"HttpOnly\",\n    \"sameSite\" in c && c.sameSite && `SameSite=${c.sameSite}`,\n    \"partitioned\" in c && c.partitioned && \"Partitioned\",\n    \"priority\" in c && c.priority && `Priority=${c.priority}`\n  ].filter(Boolean);\n  const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : \"\")}`;\n  return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(\"; \")}`;\n}\nfunction parseCookie(cookie) {\n  const map = /* @__PURE__ */ new Map();\n  for (const pair of cookie.split(/; */)) {\n    if (!pair)\n      continue;\n    const splitAt = pair.indexOf(\"=\");\n    if (splitAt === -1) {\n      map.set(pair, \"true\");\n      continue;\n    }\n    const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];\n    try {\n      map.set(key, decodeURIComponent(value != null ? value : \"true\"));\n    } catch {\n    }\n  }\n  return map;\n}\nfunction parseSetCookie(setCookie) {\n  if (!setCookie) {\n    return void 0;\n  }\n  const [[name, value], ...attributes] = parseCookie(setCookie);\n  const {\n    domain,\n    expires,\n    httponly,\n    maxage,\n    path,\n    samesite,\n    secure,\n    partitioned,\n    priority\n  } = Object.fromEntries(\n    attributes.map(([key, value2]) => [\n      key.toLowerCase().replace(/-/g, \"\"),\n      value2\n    ])\n  );\n  const cookie = {\n    name,\n    value: decodeURIComponent(value),\n    domain,\n    ...expires && { expires: new Date(expires) },\n    ...httponly && { httpOnly: true },\n    ...typeof maxage === \"string\" && { maxAge: Number(maxage) },\n    path,\n    ...samesite && { sameSite: parseSameSite(samesite) },\n    ...secure && { secure: true },\n    ...priority && { priority: parsePriority(priority) },\n    ...partitioned && { partitioned: true }\n  };\n  return compact(cookie);\n}\nfunction compact(t) {\n  const newT = {};\n  for (const key in t) {\n    if (t[key]) {\n      newT[key] = t[key];\n    }\n  }\n  return newT;\n}\nvar SAME_SITE = [\"strict\", \"lax\", \"none\"];\nfunction parseSameSite(string) {\n  string = string.toLowerCase();\n  return SAME_SITE.includes(string) ? string : void 0;\n}\nvar PRIORITY = [\"low\", \"medium\", \"high\"];\nfunction parsePriority(string) {\n  string = string.toLowerCase();\n  return PRIORITY.includes(string) ? string : void 0;\n}\nfunction splitCookiesString(cookiesString) {\n  if (!cookiesString)\n    return [];\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\n// src/request-cookies.ts\nvar RequestCookies = class {\n  constructor(requestHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    this._headers = requestHeaders;\n    const header = requestHeaders.get(\"cookie\");\n    if (header) {\n      const parsed = parseCookie(header);\n      for (const [name, value] of parsed) {\n        this._parsed.set(name, { name, value });\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this._parsed[Symbol.iterator]();\n  }\n  /**\n   * The amount of cookies received from the client\n   */\n  get size() {\n    return this._parsed.size;\n  }\n  get(...args) {\n    const name = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(name);\n  }\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed);\n    if (!args.length) {\n      return all.map(([_, value]) => value);\n    }\n    const name = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter(([n]) => n === name).map(([_, value]) => value);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  set(...args) {\n    const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;\n    const map = this._parsed;\n    map.set(name, { name, value });\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join(\"; \")\n    );\n    return this;\n  }\n  /**\n   * Delete the cookies matching the passed name or names in the request.\n   */\n  delete(names) {\n    const map = this._parsed;\n    const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value]) => stringifyCookie(value)).join(\"; \")\n    );\n    return result;\n  }\n  /**\n   * Delete all the cookies in the cookies in the request.\n   */\n  clear() {\n    this.delete(Array.from(this._parsed.keys()));\n    return this;\n  }\n  /**\n   * Format the cookies in the request as a string for logging\n   */\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join(\"; \");\n  }\n};\n\n// src/response-cookies.ts\nvar ResponseCookies = class {\n  constructor(responseHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    var _a, _b, _c;\n    this._headers = responseHeaders;\n    const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(\"set-cookie\")) != null ? _c : [];\n    const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);\n    for (const cookieString of cookieStrings) {\n      const parsed = parseSetCookie(cookieString);\n      if (parsed)\n        this._parsed.set(parsed.name, parsed);\n    }\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.\n   */\n  get(...args) {\n    const key = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(key);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.\n   */\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed.values());\n    if (!args.length) {\n      return all;\n    }\n    const key = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter((c) => c.name === key);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.\n   */\n  set(...args) {\n    const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;\n    const map = this._parsed;\n    map.set(name, normalizeCookie({ name, value, ...cookie }));\n    replace(map, this._headers);\n    return this;\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.\n   */\n  delete(...args) {\n    const [name, options] = typeof args[0] === \"string\" ? [args[0]] : [args[0].name, args[0]];\n    return this.set({ ...options, name, value: \"\", expires: /* @__PURE__ */ new Date(0) });\n  }\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map(stringifyCookie).join(\"; \");\n  }\n};\nfunction replace(bag, headers) {\n  headers.delete(\"set-cookie\");\n  for (const [, value] of bag) {\n    const serialized = stringifyCookie(value);\n    headers.append(\"set-cookie\", serialized);\n  }\n}\nfunction normalizeCookie(cookie = { name: \"\", value: \"\" }) {\n  if (typeof cookie.expires === \"number\") {\n    cookie.expires = new Date(cookie.expires);\n  }\n  if (cookie.maxAge) {\n    cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);\n  }\n  if (cookie.path === null || cookie.path === void 0) {\n    cookie.path = \"/\";\n  }\n  return cookie;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  RequestCookies,\n  ResponseCookies,\n  parseCookie,\n  parseSetCookie,\n  stringifyCookie\n});\n", "export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n", "export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n", "import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n", "import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n", "import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isBuildTimePrerendering?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  readonly hasReadableErrorStacks?: boolean\n\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid dynamic usage errors might be caught in userland. We attach them to\n   * the work store to ensure we can still fail the build, or show en error in\n   * dev mode.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidDynamicUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: string[]\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n  shouldTrackFetchMetrics: boolean\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  cacheComponentsEnabled: boolean\n  dev: boolean\n\n  /**\n   * Run the given function inside a clean AsyncLocalStorage snapshot. This is\n   * useful when generating cache entries, to ensure that the cache generation\n   * cannot read anything from the context we're currently executing in, which\n   * might include request-specific things like `cookies()` inside a\n   * `React.cache()`.\n   */\n  runInCleanSnapshot: <R, TArgs extends any[]>(\n    fn: (...args: TArgs) => R,\n    ...args: TArgs\n  ) => R\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n", "import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport type { RequestStore } from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function createCookiesWithMutableAccessCheck(\n  requestStore: RequestStore\n): ResponseCookies {\n  const wrappedCookies = new Proxy(requestStore.mutableCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(\n  requestStore: RequestStore,\n  _callingExpression: string\n) {\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n", "import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n", "export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\n", "export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n", "import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\nimport type { FallbackRouteParams } from '../request/fallback-params'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  readonly type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n  devFallbackParams?: FallbackRouteParams | null\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern =\n  | PrerenderStoreModernClient\n  | PrerenderStoreModernServer\n  | PrerenderStoreModernRuntime\n\n/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStoreModern = Exclude<\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime\n>\n\nexport interface PrerenderStoreModernClient\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender-client'\n}\n\nexport interface PrerenderStoreModernServer\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender'\n}\n\nexport interface PrerenderStoreModernRuntime\n  extends PrerenderStoreModernCommon {\n  readonly type: 'prerender-runtime'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly cookies: RequestStore['cookies']\n  readonly draftMode: RequestStore['draftMode']\n}\n\nexport interface RevalidateStore {\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\ninterface PrerenderStoreModernCommon\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  /**\n   * The render signal is aborted after React's `prerender` function is aborted\n   * (using a separate signal), which happens in two cases:\n   *\n   * 1. When all caches are filled during the prospective prerender.\n   * 2. When the final prerender is aborted immediately after the prerender was\n   *    started.\n   *\n   * It can be used to reject any pending I/O, including hanging promises. This\n   * allows React to properly track the async I/O in dev mode, which yields\n   * better owner stacks for dynamic validation errors.\n   */\n  readonly renderSignal: AbortSignal\n\n  /**\n   * This is the AbortController which represents the boundary between Prerender\n   * and dynamic. In some renders it is the same as the controller for React,\n   * but in others it is a separate controller. It should be aborted whenever we\n   * are no longer in the prerender phase of rendering. Typically this is after\n   * one task, or when you call a sync API which requires the prerender to end\n   * immediately.\n   */\n  readonly controller: AbortController\n\n  /**\n   * When not null, this signal is used to track cache reads during prerendering\n   * and to await all cache reads completing, before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  /**\n   * A mutable resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  /**\n   * An immutable resume data cache for this prerender. This may be provided\n   * instead of the `prerenderResumeDataCache` if the prerender is not supposed\n   * to fill caches, and only read from prefilled caches, e.g. when prerendering\n   * an optional fallback shell.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n\n  /**\n   * Only available in dev mode.\n   */\n  readonly captureOwnerStack: undefined | (() => string | null)\n}\n\ninterface StaticPrerenderStoreCommon {\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  readonly allowEmptyStaticShell: boolean\n}\n\nexport interface PrerenderStorePPR\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-legacy'\n  readonly rootParams: Params\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\n// /** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStore = Exclude<\n  PrerenderStore,\n  PrerenderStoreModernRuntime\n>\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n  /**\n   * Draft mode is only available if the outer work unit store is a request\n   * store and draft mode is enabled.\n   */\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface CommonUseCacheStore extends CommonCacheStore, RevalidateStore {\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n}\n\nexport interface PublicUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'cache'\n}\n\nexport interface PrivateUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'private-cache'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  /**\n   * As opposed to the public cache store, the private cache store is allowed to\n   * access the request cookies.\n   */\n  readonly cookies: ReadonlyRequestCookies\n\n  /**\n   * Private caches don't currently need to track root params in the cache key\n   * because they're not persisted anywhere, so we can allow root params access\n   * (unlike public caches)\n   */\n  readonly rootParams: Params\n}\n\nexport type UseCacheStore = PublicUseCacheStore | PrivateUseCacheStore\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  readonly type: 'unstable-cache'\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or\n * unstable_cache context. A cache store shadows an outer request store (if\n * present) as a work unit, so that we never accidentally expose any request or\n * page specific information to cache functions, unless it's explicitly desired.\n * For those exceptions, the data is copied over from the request store to the\n * cache store, instead of generally making the request store available to cache\n * functions.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function throwInvariantForMissingStore(): never {\n  throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-client':\n      // TODO eliminate fetch caching in client scope and stop exposing this data\n      // cache during SSR.\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'request':\n      return workUnitStore.renderResumeDataCache\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-client':\n      if (workUnitStore.renderResumeDataCache) {\n        // If we are in a prerender, we might have a render resume data cache\n        // that is used to read from prefilled caches.\n        return workUnitStore.renderResumeDataCache\n      }\n    // fallthrough\n    case 'prerender-ppr':\n      // Otherwise we return the mutable resume data cache here as an immutable\n      // version of the cache as it can also be used for reading.\n      return workUnitStore.prerenderResumeDataCache\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case 'prerender-legacy':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n        return workUnitStore.hmrRefreshHash\n      case 'request':\n        return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function isHmrRefresh(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): boolean {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.isHmrRefresh ?? false\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nexport function getServerComponentsHmrCache(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): ServerComponentsHmrCache | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.serverComponentsHmrCache\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n      case 'prerender-runtime':\n      case 'request':\n        return workUnitStore.draftMode\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function getCacheSignal(\n  workUnitStore: WorkUnitStore\n): CacheSignal | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n      return workUnitStore.cacheSignal\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRuntimeStagePromise(\n  workUnitStore: WorkUnitStore\n): Promise<void> | null {\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n    case 'private-cache':\n      return workUnitStore.runtimeStagePromise\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n", "const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n", "const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n", "export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(underlying: T): Promise<T> {\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n", "export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n", "export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n", "// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n", "/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */\nexport function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {\n  if (dynamicTracking.syncDynamicErrorWithStack) {\n    // the server did something sync dynamic, likely\n    // leading to an early termination of the prerender.\n    console.error(dynamicTracking.syncDynamicErrorWithStack)\n  }\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    if (serverDynamic.syncDynamicErrorWithStack) {\n      // There is no shell and the server did something sync dynamic likely\n      // leading to an early termination of the prerender before the shell\n      // could be completed. We terminate the build/validating render.\n      logDisallowedDynamicError(\n        workStore,\n        serverDynamic.syncDynamicErrorWithStack\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n", "import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n", "import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n", "import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n", "import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n", "import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n          const error = new Error(\n            `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, cookies)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n          return makeHangingCookies(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // We need track dynamic access here eagerly to keep continuity with\n          // how cookies has worked in PPR without cacheComponents.\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // We track dynamic access here so we don't need to wrap the cookies\n          // in individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedCookies(workUnitStore.cookies)\n          )\n        case 'private-cache':\n          if (process.env.__NEXT_CACHE_COMPONENTS) {\n            return makeUntrackedCookies(workUnitStore.cookies)\n          }\n\n          return makeUntrackedExoticCookies(workUnitStore.cookies)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          let underlyingCookies: ReadonlyRequestCookies\n\n          if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n            // We can't conditionally return different types here based on the context.\n            // To avoid confusion, we always return the readonly type here.\n            underlyingCookies =\n              workUnitStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n          } else {\n            underlyingCookies = workUnitStore.cookies\n          }\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n              return makeUntrackedCookiesWithDevWarnings(\n                underlyingCookies,\n                workStore?.route\n              )\n            }\n\n            return makeUntrackedExoticCookiesWithDevWarnings(\n              underlyingCookies,\n              workStore?.route\n            )\n          } else {\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n              return makeUntrackedCookies(underlyingCookies)\n            }\n\n            return makeUntrackedExoticCookies(underlyingCookies)\n          }\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...cookies()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = '`cookies().size`'\n        syncIODev(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        syncIODev(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()` or implicit casting'\n        syncIODev(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\n// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the\n// sync access without actually defining the cookies properties on the promise.\nfunction makeUntrackedCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(underlyingCookies)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case Symbol.iterator: {\n          warnForSyncAccess(route, '`...cookies()` or similar iteration')\n          break\n        }\n        case 'size':\n        case 'get':\n        case 'getAll':\n        case 'has':\n        case 'set':\n        case 'delete':\n        case 'clear':\n        case 'toString': {\n          warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the cookies object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n", "import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n", "import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedHeaders = ReadonlyHeaders\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const callingExpression = 'headers'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedExoticHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"headers\" inside \"use cache: private\". Accessing \"headers\" inside a private cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-runtime':\n          return makeHangingHeaders(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no cacheComponents)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without cacheComponents.\n          // TODO consider switching the semantic to throw on property access instead\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n              return makeUntrackedHeadersWithDevWarnings(\n                workUnitStore.headers,\n                workStore?.route\n              )\n            }\n\n            return makeUntrackedExoticHeadersWithDevWarnings(\n              workUnitStore.headers,\n              workStore?.route\n            )\n          } else {\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\n              return makeUntrackedHeaders(workUnitStore.headers)\n            }\n\n            return makeUntrackedExoticHeaders(workUnitStore.headers)\n          }\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: underlyingHeaders.append.bind(underlyingHeaders),\n    },\n    delete: {\n      value: underlyingHeaders.delete.bind(underlyingHeaders),\n    },\n    get: {\n      value: underlyingHeaders.get.bind(underlyingHeaders),\n    },\n    has: {\n      value: underlyingHeaders.has.bind(underlyingHeaders),\n    },\n    set: {\n      value: underlyingHeaders.set.bind(underlyingHeaders),\n    },\n    getSetCookie: {\n      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n    },\n    forEach: {\n      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n    },\n    keys: {\n      value: underlyingHeaders.keys.bind(underlyingHeaders),\n    },\n    values: {\n      value: underlyingHeaders.values.bind(underlyingHeaders),\n    },\n    entries: {\n      value: underlyingHeaders.entries.bind(underlyingHeaders),\n    },\n    [Symbol.iterator]: {\n      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)\n\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.append.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.delete.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.getSetCookie.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        syncIODev(route, expression)\n        return underlyingHeaders.forEach.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.values.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.entries.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...headers()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingHeaders[Symbol.iterator].apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\n// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the\n// sync access without actually defining the headers properties on the promise.\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case Symbol.iterator: {\n          warnForSyncAccess(route, '`...headers()` or similar iteration')\n          break\n        }\n        case 'append':\n        case 'delete':\n        case 'get':\n        case 'has':\n        case 'set':\n        case 'getSetCookie':\n        case 'forEach':\n        case 'keys':\n        case 'values':\n        case 'entries': {\n          warnForSyncAccess(route, `\\`headers().${prop}\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the headers object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'string' ? `'${arg}'` : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\ntype HeadersExtensions = {\n  [K in keyof ReadonlyHeaders]: unknown\n}\n", "import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedDraftMode = DraftMode\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n      return delayUntilRuntimeStage(\n        workUnitStore,\n        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n      )\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store (or a runtime prerender),\n      // and if draft mode is enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  let promise: Promise<DraftMode>\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n      return createDraftModeWithDevWarnings(draftModeProvider, route)\n    }\n\n    promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n      return Promise.resolve(new DraftMode(draftModeProvider))\n    }\n\n    promise = createExoticDraftMode(draftModeProvider)\n  }\n\n  CachedDraftModes.set(cacheKey, promise)\n\n  return promise\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createExoticDraftMode(\n  underlyingProvider: null | DraftModeProvider\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      return instance.isEnabled\n    },\n    enumerable: true,\n    configurable: true,\n  })\n  ;(promise as any).enable = instance.enable.bind(instance)\n  ;(promise as any).disable = instance.disable.bind(instance)\n\n  return promise\n}\n\nfunction createExoticDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      const expression = '`draftMode().isEnabled`'\n      syncIODev(route, expression)\n      return instance.isEnabled\n    },\n    enumerable: true,\n    configurable: true,\n  })\n\n  Object.defineProperty(promise, 'enable', {\n    value: function get() {\n      const expression = '`draftMode().enable()`'\n      syncIODev(route, expression)\n      return instance.enable.apply(instance, arguments as any)\n    },\n  })\n\n  Object.defineProperty(promise, 'disable', {\n    value: function get() {\n      const expression = '`draftMode().disable()`'\n      syncIODev(route, expression)\n      return instance.disable.apply(instance, arguments as any)\n    },\n  })\n\n  return promise\n}\n\n// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync\n// access without actually defining the draftMode properties on the promise.\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()', this.enable)\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()', this.disable)\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore?.phase === 'after') {\n      throw new Error(\n        `Route ${workStore.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, constructorOpt)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n\n        case 'prerender':\n        case 'prerender-runtime': {\n          const error = new Error(\n            `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          return abortAndThrowOnSynchronousRequestDataAccess(\n            workStore.route,\n            expression,\n            error,\n            workUnitStore\n          )\n        }\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          workStore.dynamicUsageDescription = expression\n          workStore.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n}\n", "module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n"],
  "mappings": "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",
  "names": ["RequestCookies", "ResponseCookies", "stringifyCookie", "ReflectAdapter", "get", "target", "prop", "receiver", "value", "Reflect", "bind", "set", "has", "deleteProperty", "bindSnapshot", "createAsyncLocalStorage", "createSnapshot", "sharedAsyncLocalStorageNotAvailableError", "Error", "FakeAsyncLocalStorage", "disable", "getStore", "undefined", "run", "exit", "enterWith", "bind", "fn", "maybeGlobalAsyncLocalStorage", "globalThis", "AsyncLocalStorage", "snapshot", "args", "workAsyncStorageInstance", "createAsyncLocalStorage", "workAsyncStorage", "workAsyncStorageInstance", "MutableRequestCookiesAdapter", "ReadonlyRequestCookiesError", "RequestCookiesAdapter", "appendMutableCookies", "areCookiesMutableInCurrentPhase", "createCookiesWithMutableAccessCheck", "getModifiedCookieValues", "responseCookiesToRequestCookies", "Error", "constructor", "callable", "seal", "cookies", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "SYMBOL_MODIFY_COOKIE_VALUES", "Symbol", "for", "modified", "Array", "isArray", "length", "headers", "mutableCookies", "modifiedCookieValues", "resCookies", "ResponseCookies", "returnedCookies", "getAll", "cookie", "set", "wrap", "onUpdateCookies", "responseCookies", "Headers", "modifiedValues", "modifiedCookies", "Set", "updateResponseCookies", "workStore", "workAsyncStorage", "getStore", "pathWasRevalidated", "allCookies", "filter", "c", "has", "name", "serializedCookies", "tempCookies", "push", "toString", "wrappedCookies", "args", "add", "delete", "requestStore", "ensureCookiesAreStillMutable", "phase", "_callingExpression", "requestCookies", "RequestCookies", "workUnitAsyncStorageInstance", "createAsyncLocalStorage", "ACTION_HEADER", "FLIGHT_HEADERS", "NEXT_ACTION_NOT_FOUND_HEADER", "NEXT_DID_POSTPONE_HEADER", "NEXT_HMR_REFRESH_HASH_COOKIE", "NEXT_HMR_REFRESH_HEADER", "NEXT_IS_PRERENDER_HEADER", "NEXT_REWRITTEN_PATH_HEADER", "NEXT_REWRITTEN_QUERY_HEADER", "NEXT_ROUTER_PREFETCH_HEADER", "NEXT_ROUTER_SEGMENT_PREFETCH_HEADER", "NEXT_ROUTER_STALE_TIME_HEADER", "NEXT_ROUTER_STATE_TREE_HEADER", "NEXT_RSC_UNION_QUERY", "NEXT_URL", "RSC_CONTENT_TYPE_HEADER", "RSC_HEADER", "InvariantError", "Error", "constructor", "message", "options", "endsWith", "name", "getCacheSignal", "getDraftModeProviderForCacheScope", "getHmrRefreshHash", "getPrerenderResumeDataCache", "getRenderResumeDataCache", "getRuntimeStagePromise", "getServerComponentsHmrCache", "isHmrRefresh", "throwForMissingRequestStore", "throwInvariantForMissingStore", "workUnitAsyncStorage", "workUnitAsyncStorageInstance", "callingExpression", "Error", "InvariantError", "workUnitStore", "type", "prerenderResumeDataCache", "renderResumeDataCache", "workStore", "dev", "hmrRefreshHash", "cookies", "get", "NEXT_HMR_REFRESH_HASH_COOKIE", "value", "undefined", "serverComponentsHmrCache", "isDraftMode", "draftMode", "cacheSignal", "runtimeStagePromise", "DynamicServerError", "isDynamicServerError", "DYNAMIC_ERROR_CODE", "Error", "constructor", "description", "digest", "err", "StaticGenBailoutError", "isStaticGenBailoutError", "NEXT_STATIC_GEN_BAILOUT", "Error", "code", "error", "isHangingPromiseRejectionError", "makeDevtoolsIOAwarePromise", "makeHangingPromise", "err", "digest", "HANGING_PROMISE_REJECTION", "HangingPromiseRejectionError", "Error", "constructor", "route", "expression", "abortListenersBySignal", "WeakMap", "signal", "aborted", "Promise", "reject", "hangingPromise", "_", "boundRejection", "bind", "currentListeners", "get", "push", "listeners", "set", "addEventListener", "i", "length", "once", "catch", "ignoreReject", "underlying", "resolve", "setTimeout", "METADATA_BOUNDARY_NAME", "OUTLET_BOUNDARY_NAME", "ROOT_LAYOUT_BOUNDARY_NAME", "VIEWPORT_BOUNDARY_NAME", "atLeastOneTask", "scheduleImmediate", "scheduleOnNextTick", "waitAtLeastOneReactRenderTask", "cb", "Promise", "resolve", "then", "process", "env", "NEXT_RUNTIME", "setTimeout", "nextTick", "setImmediate", "r", "BailoutToCSRError", "isBailoutToCSRError", "BAILOUT_TO_CSR", "Error", "constructor", "reason", "digest", "err", "Postpone", "PreludeState", "abortAndThrowOnSynchronousRequestDataAccess", "abortOnSynchronousPlatformIOAccess", "accessedDynamicData", "annotateDynamicAccess", "consumeDynamicAccess", "createDynamicTrackingState", "createDynamicValidationState", "createHangingInputAbortSignal", "createRenderInBrowserAbortSignal", "delayUntilRuntimeStage", "formatDynamicAPIAccesses", "getFirstDynamicReason", "isDynamicPostpone", "isPrerenderInterruptedError", "logDisallowedDynamicError", "markCurrentScopeAsDynamic", "postponeWithTracking", "throwIfDisallowedDynamic", "throwToInterruptStaticGeneration", "trackAllowedDynamicAccess", "trackDynamicDataInDynamicRender", "trackSynchronousPlatformIOAccessInDev", "trackSynchronousRequestDataAccessInDev", "useDynamicRouteParams", "warnOnSyncDynamicError", "hasPostpone", "React", "unstable_postpone", "isDebugDynamicAccesses", "dynamicAccesses", "syncDynamicErrorWithStack", "hasSuspenseAboveBody", "hasDynamicMetadata", "hasDynamicViewport", "hasAllowedDynamic", "dynamicErrors", "trackingState", "expression", "store", "workUnitStore", "type", "forceDynamic", "forceStatic", "dynamicShouldError", "StaticGenBailoutError", "route", "dynamicTracking", "revalidate", "err", "DynamicServerError", "dynamicUsageDescription", "dynamicUsageStack", "stack", "process", "usedDynamic", "prerenderStore", "abortOnSynchronousDynamicDataAccess", "reason", "error", "createPrerenderInterruptedError", "controller", "abort", "push", "Error", "undefined", "errorWithStack", "requestStore", "prerenderPhase", "prerenderSignal", "signal", "aborted", "console", "workUnitAsyncStorage", "getStore", "assertPostpone", "createPostponeReason", "message", "isDynamicPostponeReason", "includes", "NEXT_PRERENDER_INTERRUPTED", "digest", "length", "serverDynamic", "clientDynamic", "filter", "access", "map", "split", "slice", "line", "join", "AbortController", "BailoutToCSRError", "cacheSignal", "inputReady", "then", "runtimeStagePromise", "getRuntimeStagePromise", "scheduleOnNextTick", "workStore", "workAsyncStorage", "fallbackParams", "fallbackRouteParams", "size", "use", "makeHangingPromise", "renderSignal", "InvariantError", "hasSuspenseRegex", "bodyAndImplicitTags", "hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex", "RegExp", "ROOT_LAYOUT_BOUNDARY_NAME", "hasMetadataRegex", "METADATA_BOUNDARY_NAME", "hasViewportRegex", "VIEWPORT_BOUNDARY_NAME", "hasOutletRegex", "OUTLET_BOUNDARY_NAME", "componentStack", "dynamicValidation", "test", "createErrorWithComponentOrOwnerStack", "ownerStack", "captureOwnerStack", "name", "dev", "hasReadableErrorStacks", "prelude", "i", "result", "createDedupedByCallsiteServerErrorLoggerDev", "errorRef", "current", "cache", "React", "fn", "logErrorOrWarn", "process", "env", "__NEXT_CACHE_COMPONENTS", "console", "error", "warn", "flushCurrentErrorIfNew", "key", "getMessage", "logDedupedError", "args", "message", "callStackFrames", "Error", "stack", "split", "undefined", "length", "afterTaskAsyncStorageInstance", "createAsyncLocalStorage", "afterTaskAsyncStorage", "isRequestAPICallableInsideAfter", "throwForSearchParamsAccessInUseCache", "throwWithStaticGenerationBailoutError", "throwWithStaticGenerationBailoutErrorWithDynamicError", "route", "expression", "StaticGenBailoutError", "workStore", "constructorOpt", "error", "Error", "captureStackTrace", "invalidDynamicUsageError", "afterTaskStore", "afterTaskAsyncStorage", "getStore", "rootTaskSpawnPhase", "cookies", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingCookies", "createEmptyCookies", "makeUntrackedExoticCookies", "dynamicShouldError", "StaticGenBailoutError", "type", "error", "captureStackTrace", "invalidDynamicUsageError", "makeHangingCookies", "exportName", "InvariantError", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "delayUntilRuntimeStage", "makeUntrackedCookies", "process", "env", "__NEXT_CACHE_COMPONENTS", "trackDynamicDataInDynamicRender", "areCookiesMutableInCurrentPhase", "userspaceMutableCookies", "makeUntrackedCookiesWithDevWarnings", "makeUntrackedExoticCookiesWithDevWarnings", "throwForMissingRequestStore", "RequestCookiesAdapter", "seal", "RequestCookies", "Headers", "CachedCookies", "WeakMap", "prerenderStore", "cachedPromise", "get", "promise", "makeHangingPromise", "renderSignal", "set", "cachedCookies", "Promise", "resolve", "Object", "defineProperties", "Symbol", "iterator", "value", "bind", "polyfilledResponseCookiesIterator", "size", "getAll", "has", "delete", "clear", "polyfilledResponseCookiesClear", "toString", "makeDevtoolsIOAwarePromise", "expression", "syncIODev", "apply", "arguments", "call", "writable", "length", "describeNameArg", "arg", "proxiedPromise", "Proxy", "target", "prop", "receiver", "warnForSyncAccess", "ReflectAdapter", "name", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "createDedupedByCallsiteServerErrorLoggerDev", "createCookiesAccessError", "prefix", "map", "c", "values", "returnable", "cookie", "HeadersAdapter", "ReadonlyHeadersError", "Error", "constructor", "callable", "Headers", "headers", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "lowercased", "toLowerCase", "original", "Object", "keys", "find", "o", "set", "value", "has", "deleteProperty", "seal", "merge", "Array", "isArray", "join", "from", "append", "name", "existing", "push", "delete", "forEach", "callbackfn", "thisArg", "entries", "call", "key", "values", "Symbol", "iterator", "headers", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingHeaders", "HeadersAdapter", "seal", "Headers", "makeUntrackedExoticHeaders", "type", "error", "captureStackTrace", "invalidDynamicUsageError", "dynamicShouldError", "StaticGenBailoutError", "makeHangingHeaders", "exportName", "InvariantError", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "trackDynamicDataInDynamicRender", "process", "env", "__NEXT_CACHE_COMPONENTS", "makeUntrackedHeadersWithDevWarnings", "makeUntrackedExoticHeadersWithDevWarnings", "makeUntrackedHeaders", "throwForMissingRequestStore", "CachedHeaders", "WeakMap", "prerenderStore", "cachedHeaders", "get", "promise", "makeHangingPromise", "renderSignal", "set", "Promise", "resolve", "Object", "defineProperties", "append", "value", "bind", "delete", "has", "getSetCookie", "forEach", "keys", "values", "entries", "Symbol", "iterator", "makeDevtoolsIOAwarePromise", "expression", "describeNameArg", "arguments", "syncIODev", "apply", "_delete", "proxiedPromise", "Proxy", "target", "prop", "receiver", "warnForSyncAccess", "ReflectAdapter", "arg", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "createDedupedByCallsiteServerErrorLoggerDev", "createHeadersAccessError", "prefix", "draftMode", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "throwForMissingRequestStore", "type", "delayUntilRuntimeStage", "createOrGetCachedDraftMode", "draftModeProvider", "getDraftModeProviderForCacheScope", "cacheKey", "NullDraftMode", "cachedDraftMode", "CachedDraftModes", "get", "promise", "isPrefetchRequest", "route", "process", "env", "__NEXT_CACHE_COMPONENTS", "createDraftModeWithDevWarnings", "createExoticDraftModeWithDevWarnings", "Promise", "resolve", "DraftMode", "createExoticDraftMode", "set", "WeakMap", "underlyingProvider", "instance", "Object", "defineProperty", "isEnabled", "enumerable", "configurable", "enable", "bind", "disable", "expression", "syncIODev", "value", "apply", "arguments", "proxiedPromise", "Proxy", "target", "prop", "receiver", "warnForSyncAccess", "ReflectAdapter", "constructor", "provider", "_provider", "trackDynamicDraftMode", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "createDedupedByCallsiteServerErrorLoggerDev", "createDraftModeAccessError", "prefix", "Error", "constructorOpt", "phase", "dynamicShouldError", "StaticGenBailoutError", "error", "captureStackTrace", "invalidDynamicUsageError", "abortAndThrowOnSynchronousRequestDataAccess", "exportName", "InvariantError", "postponeWithTracking", "dynamicTracking", "revalidate", "err", "DynamicServerError", "dynamicUsageDescription", "dynamicUsageStack", "stack", "trackDynamicDataInDynamicRender", "require_headers"]
}
