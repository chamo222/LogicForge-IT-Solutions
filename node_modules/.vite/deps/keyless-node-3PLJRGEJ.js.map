{
  "version": 3,
  "sources": ["../../@clerk/nextjs/src/server/keyless-custom-headers.ts", "../../@clerk/nextjs/src/server/keyless-node.ts"],
  "sourcesContent": ["'use server';\n\nimport { headers } from 'next/headers';\n\ninterface MetadataHeaders {\n  nodeVersion?: string;\n  nextVersion?: string;\n  npmConfigUserAgent?: string;\n  userAgent: string;\n  port?: string;\n  host: string;\n  xHost: string;\n  xPort: string;\n  xProtocol: string;\n  xClerkAuthStatus: string;\n}\n\n/**\n * Collects metadata from the environment and request headers\n */\nexport async function collectKeylessMetadata(): Promise<MetadataHeaders> {\n  const headerStore = await headers(); // eslint-disable-line\n\n  return {\n    nodeVersion: process.version,\n    nextVersion: getNextVersion(),\n    npmConfigUserAgent: process.env.npm_config_user_agent, // eslint-disable-line\n    userAgent: headerStore.get('User-Agent') ?? 'unknown user-agent',\n    port: process.env.PORT, // eslint-disable-line\n    host: headerStore.get('host') ?? 'unknown host',\n    xPort: headerStore.get('x-forwarded-port') ?? 'unknown x-forwarded-port',\n    xHost: headerStore.get('x-forwarded-host') ?? 'unknown x-forwarded-host',\n    xProtocol: headerStore.get('x-forwarded-proto') ?? 'unknown x-forwarded-proto',\n    xClerkAuthStatus: headerStore.get('x-clerk-auth-status') ?? 'unknown x-clerk-auth-status',\n  };\n}\n\n/**\n * Extracts Next.js version from process title\n */\nfunction getNextVersion(): string | undefined {\n  try {\n    return process.title ?? 'unknown-process-title'; // 'next-server (v15.4.5)'\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Converts metadata to HTTP headers\n */\nexport function formatMetadataHeaders(metadata: MetadataHeaders): Headers {\n  const headers = new Headers();\n\n  if (metadata.nodeVersion) {\n    headers.set('Clerk-Node-Version', metadata.nodeVersion);\n  }\n\n  if (metadata.nextVersion) {\n    headers.set('Clerk-Next-Version', metadata.nextVersion);\n  }\n\n  if (metadata.npmConfigUserAgent) {\n    headers.set('Clerk-NPM-Config-User-Agent', metadata.npmConfigUserAgent);\n  }\n\n  if (metadata.userAgent) {\n    headers.set('Clerk-Client-User-Agent', metadata.userAgent);\n  }\n\n  if (metadata.port) {\n    headers.set('Clerk-Node-Port', metadata.port);\n  }\n\n  if (metadata.host) {\n    headers.set('Clerk-Client-Host', metadata.host);\n  }\n\n  if (metadata.xPort) {\n    headers.set('Clerk-X-Port', metadata.xPort);\n  }\n\n  if (metadata.xHost) {\n    headers.set('Clerk-X-Host', metadata.xHost);\n  }\n\n  if (metadata.xProtocol) {\n    headers.set('Clerk-X-Protocol', metadata.xProtocol);\n  }\n\n  if (metadata.xClerkAuthStatus) {\n    headers.set('Clerk-Auth-Status', metadata.xClerkAuthStatus);\n  }\n\n  return headers;\n}\n", "import type { AccountlessApplication } from '@clerk/backend';\n\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeCwdOrThrow, nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\nimport { collectKeylessMetadata, formatMetadataHeaders } from './keyless-custom-headers';\n\n/**\n * The Clerk-specific directory name.\n */\nconst CLERK_HIDDEN = '.clerk';\n\n/**\n * The Clerk-specific lock file that is used to mitigate multiple key creation.\n * This is automatically cleaned up.\n */\nconst CLERK_LOCK = 'clerk.lock';\n\n/**\n * The `.clerk/` directory is NOT safe to be committed as it may include sensitive information about a Clerk instance.\n * It may include an instance's secret key and the secret token for claiming that instance.\n */\nfunction updateGitignore() {\n  const { existsSync, writeFileSync, readFileSync, appendFileSync } = nodeFsOrThrow();\n\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  const gitignorePath = path.join(cwd(), '.gitignore');\n  if (!existsSync(gitignorePath)) {\n    writeFileSync(gitignorePath, '');\n  }\n\n  // Check if `.clerk/` entry exists in .gitignore\n  const gitignoreContent = readFileSync(gitignorePath, 'utf-8');\n  const COMMENT = `# clerk configuration (can include secrets)`;\n  if (!gitignoreContent.includes(CLERK_HIDDEN + '/')) {\n    appendFileSync(gitignorePath, `\\n${COMMENT}\\n/${CLERK_HIDDEN}/\\n`);\n  }\n}\n\nconst generatePath = (...slugs: string[]) => {\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  return path.join(cwd(), CLERK_HIDDEN, ...slugs);\n};\n\nconst _TEMP_DIR_NAME = '.tmp';\nconst getKeylessConfigurationPath = () => generatePath(_TEMP_DIR_NAME, 'keyless.json');\nconst getKeylessReadMePath = () => generatePath(_TEMP_DIR_NAME, 'README.md');\n\nlet isCreatingFile = false;\n\nexport function safeParseClerkFile(): AccountlessApplication | undefined {\n  const { readFileSync } = nodeFsOrThrow();\n  try {\n    const CONFIG_PATH = getKeylessConfigurationPath();\n    let fileAsString;\n    try {\n      fileAsString = readFileSync(CONFIG_PATH, { encoding: 'utf-8' }) || '{}';\n    } catch {\n      fileAsString = '{}';\n    }\n    return JSON.parse(fileAsString) as AccountlessApplication;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Using both an in-memory and file system lock seems to be the most effective solution.\n */\nconst lockFileWriting = () => {\n  const { writeFileSync } = nodeFsOrThrow();\n\n  isCreatingFile = true;\n\n  writeFileSync(\n    CLERK_LOCK,\n    // In the rare case, the file persists give the developer enough context.\n    'This file can be deleted. Please delete this file and refresh your application',\n    {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    },\n  );\n};\n\nconst unlockFileWriting = () => {\n  const { rmSync } = nodeFsOrThrow();\n\n  try {\n    rmSync(CLERK_LOCK, { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  isCreatingFile = false;\n};\n\nconst isFileWritingLocked = () => {\n  const { existsSync } = nodeFsOrThrow();\n  return isCreatingFile || existsSync(CLERK_LOCK);\n};\n\nasync function createOrReadKeyless(): Promise<AccountlessApplication | null> {\n  const { writeFileSync, mkdirSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return null;\n  }\n\n  lockFileWriting();\n\n  const CONFIG_PATH = getKeylessConfigurationPath();\n  const README_PATH = getKeylessReadMePath();\n\n  mkdirSync(generatePath(_TEMP_DIR_NAME), { recursive: true });\n  updateGitignore();\n\n  /**\n   * When the configuration file exists, always read the keys from the file\n   */\n  const envVarsMap = safeParseClerkFile();\n  if (envVarsMap?.publishableKey && envVarsMap?.secretKey) {\n    unlockFileWriting();\n\n    return envVarsMap;\n  }\n\n  /**\n   * At this step, it is safe to create new keys and store them.\n   */\n  const client = createClerkClientWithOptions({});\n\n  // Collect metadata\n  const keylessHeaders = await collectKeylessMetadata()\n    .then(formatMetadataHeaders)\n    .catch(() => new Headers());\n\n  const accountlessApplication = await client.__experimental_accountlessApplications\n    .createAccountlessApplication({ requestHeaders: keylessHeaders })\n    .catch(() => null);\n\n  if (accountlessApplication) {\n    writeFileSync(CONFIG_PATH, JSON.stringify(accountlessApplication), {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n\n    // TODO-KEYLESS: Add link to official documentation.\n    const README_NOTIFICATION = `\n## DO NOT COMMIT\nThis directory is auto-generated from \\`@clerk/nextjs\\` because you are running in Keyless mode. Avoid committing the \\`.clerk/\\` directory as it includes the secret key of the unclaimed instance.\n  `;\n\n    writeFileSync(README_PATH, README_NOTIFICATION, {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n  }\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n\n  return accountlessApplication;\n}\n\nfunction removeKeyless() {\n  const { rmSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return undefined;\n  }\n\n  lockFileWriting();\n\n  try {\n    rmSync(generatePath(), { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n}\n\nexport { createOrReadKeyless, removeKeyless };\n"],
  "mappings": "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",
  "names": ["headers"]
}
